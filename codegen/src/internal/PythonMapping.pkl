// ===----------------------------------------------------------------------===//
// Copyright Â© 2024 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ===----------------------------------------------------------------------===//
@Unlisted
abstract module pkl.python.internal.PythonMapping

import "PythonMapping.pkl"
import "Type.pkl"
import "pkl:reflect"
import "utils.pkl"

/// The Python module name, e.g. `AppConfig`
///
/// This determines whether imports need to be generated or not.
pythonModuleName: String?

/// The name for the namespace (generated as an enum)
fixed namespaceName: String =
  utils.getPythonNameAnnotation(source.enclosingDeclaration)
    ?? utils.normalizeName(source.enclosingDeclaration.name.replaceAll(".", "_"))

/// The exposed simple name of this type (either the enum's name or the struct or protocol name).
name: String

/// All names exposed by this mapping
///
/// For example, if there is both a protocol and a struct implementation, this includes both names.
names: List<String>

seenMappings: List<PythonMapping>

/// The source for this mapping
source: reflect.TypeDeclaration

/// The exposed Python type.
type: Type

/// The set of names already seen prior to creating mappings for this module.
existingNames: List<String> = seenMappings.flatMap((it) ->
  if (it.pythonModuleName == module.pythonModuleName) it.names
  else List()
)

class TypeAlias extends PythonMapping {
  local self = this

  alias: reflect.TypeAlias = self.source as reflect.TypeAlias

  name = utils.toPythonName(self.source)

  names = List(name)

  type = new Type.Declared {
    typeName = name
    namespaceName = self.namespaceName
    pythonModuleName = self.pythonModuleName
  }
}

class Class extends PythonMapping {
  local self = this

  clazz: reflect.Class = self.source as reflect.Class

  names = List(inner.name).filterNonNull() as List<String>

  type = (inner).type

  name = utils.toPythonName(clazz)

  inner: ClassInner = new ClassInner{
    name = self.name
    clazz = self.clazz
    type = new Type.Declared {
      namespaceName = self.namespaceName
      pythonModuleName = self.pythonModuleName
      typeName = name
    }
  }
}

class ClassInner {
  name: String
  clazz: reflect.Class
  type: Type
}